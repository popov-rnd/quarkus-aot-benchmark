# Quarkus AOT&JIT Benchmarks

Benchmark project to compare JIT (JAR) vs AOT (native image) with Quarkus.
We measure:

- Compilation time
- Startup time
- Memory footprint
- Artifact size

Tested with Maven (wrapper), JVM/GraalVM 21+.

## JIT compilation

### Packaging uber-jar and running the app

In Quarkus, an Ã¼ber-jar is simply a single runnable JAR that contains:

- Your application classes
- All dependencies (third-party JARs) merged inside
- Quarkusâ€™s generated bytecode from its build-time augmentation

Itâ€™s the "one file to run them all" packaging option.

More [Uber Jar](https://quarkus.io/guides/maven-tooling#uber-jar-maven).

```shell script
./mvnw package -Dquarkus.package.jar.type=uber-jar
```

It is now runnable using:

`java -jar target/*-runner.jar`.

## AOT compilation

### Creating a native executable

You can create a native executable using:

```shell script
./mvnw package -Dnative
```

Or, if you don't have GraalVM installed, you can run the native executable build in a container using:

```shell script
./mvnw package -Dnative -Dquarkus.native.container-build=true
```

You can then execute your native executable with: 

`./target/quarkus-aot-benchmark-1.0-SNAPSHOT-runner`

More [Native image](https://quarkus.io/guides/maven-tooling#building-a-native-executable)


## Running Benchmarks

Run both builds (Ã¼ber-jar and native)

ðŸ“Š Measure:

- Build time â†’ taken from Mavenâ€™s own build output (e.g., [INFO] BUILD SUCCESS in _ s).
- Startup time â†’ taken from Quarkusâ€™s startup log (e.g., Quarkus started in _ s).
- Memory usage â†’ from ps after startup, Processes tab in Linux Mintâ€™s System Monitor is essentially a GUI wrapper around what commands like ps and top show in the terminal.
- Artifact size â†’ from ls -lh or direct filesystem metadata.