# Quarkus AOT&JIT Benchmarks

Benchmark project to compare JIT (JAR) vs AOT (native image) with Quarkus.

We measure:

- Startup time;
- Memory footprint (rss = shared + private);
- Artifact size;
- Compilation time (secondary).

Tested with Maven (wrapper), JVM: Temurin 25 / GraalVM Mandrel 25.

## JIT compilation

In Quarkus, the application entry point is generated at build time by the framework; no user-defined **main()** method is required.

### Packaging soft-jar and running the app

In Quarkus, the ***soft-jar*** (default packaging) is a *directory-based* runnable application, not a single JAR.

It consists of:

- Application runner JAR: *quarkus-run.jar* (thin launcher)
- Application classes: *quarkus-app/app/*
- Dependencies: *quarkus-app/lib/*
- Quarkus-generated bytecode & metadata: *quarkus-app/quarkus/*

This layout is optimized for:

- fast startup
- incremental rebuilds
- container layering
- native-image friendliness

More: (Fast Jar packaging)[https://quarkus.io/guides/maven-tooling#fast-jar]

```shell script
./mvnw package
```

(Default jar.type=fast-jar is used.)

It is now runnable using:

`java -jar target/quarkus-app/quarkus-run.jar`.

***Important***:
The entire *quarkus-app/* directory must be present.
*quarkus-run.jar* cannot run standalone.

## AOT compilation

### Creating a native executable

There are **2** main ways to build a Quarkus native app:

- Using GraalVM Native Image directly (local build), where Quarkus invokes native-image on the host machine to produce a standalone native executable.
- Using a container-based native build, where Quarkus runs the same native-image process inside a container image, producing an identical native executable without requiring GraalVM to be installed locally.

In both cases, the output is a single native executable.
The container-based approach only changes where the build runs, not what is produced.


#### GraalVM is installed in OS

You can create a native executable using:

```shell script
./mvnw package -Dnative
```

This requires a local GraalVM distribution with the native-image component installed and configured as the active JDK.

Before building, ensure Maven runs on GraalVM:

```
./mvnw -v
```

Expected output (example):

>Java version: 25, vendor: GraalVM

#### GraalVM is NOT installed in OS

Or, if you don't have GraalVM installed, you can run the native executable build in a container using:

```shell script
./mvnw package -Dnative -Dquarkus.native.container-build=true
```

In this mode:

- Quarkus runs native-image inside a container
- No GraalVM installation is required on the host
- The resulting artifact is identical to a local native build

You can then execute your native executable with: 

`./target/quarkus-aot-benchmark-1.0-SNAPSHOT-runner`

***Important notes (recommended)***

- Docker (or compatible container runtime) must be available
- The GraalVM/Mandrel version is defined by the builder image
- JVM packaging options (fast-jar, uber-jar) are ignored for native builds

More [Native image](https://quarkus.io/guides/maven-tooling#building-a-native-executable)


## Running Benchmarks

Metrics collected with the (*script*)[https://github.com/popov-rnd/script-aot-benchmark.git]

### Metrics

- **Startup time** -> taken from .sh script output after first http 200 response (not relying on, Spring Boot's logs started in _ s).
- **Memory usage** -> from standard RSS Unix tool, also in .sh script.
- **Artifact size** -> from ls -lh or direct filesystem metadata.
- ***Build time*** -> taken from Mavenâ€™s own build output (e.g., [INFO] BUILD SUCCESS in _ s).